% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scan_sequences.R
\name{scan_sequences}
\alias{scan_sequences}
\title{Scan sequences for matches to input motifs.}
\usage{
scan_sequences(motifs, sequences, threshold = 0.001,
  threshold.type = "pvalue", RC = FALSE, use.freq = 1, verbose = 0,
  nthreads = 1, motif_pvalue.k = 8, use.gaps = TRUE,
  allow.nonfinite = FALSE, warn.NA = TRUE, calc.pvals = FALSE)
}
\arguments{
\item{motifs}{See \code{convert_motifs()} for acceptable motif formats.}

\item{sequences}{\code{\link{XStringSet}} Sequences to scan. Alphabet
should match motif.}

\item{threshold}{\code{numeric(1)} See details.}

\item{threshold.type}{\code{character(1)} One of \code{c('logodds', 'logodds.abs', 'pvalue')}. See details.}

\item{RC}{\code{logical(1)} If \code{TRUE}, check reverse complement of input
sequences.}

\item{use.freq}{\code{numeric(1)} The default, 1, uses the motif matrix (from
the \code{motif['motif']} slot) to search for sequences. If a higher
number is used, then the matching k-let matrix from the
\code{motif['multifreq']} slot is used. See \code{\link[=add_multifreq]{add_multifreq()}}.}

\item{verbose}{\code{numeric(1)} Describe progress, from none (\code{0}) to
verbose (\code{3}).}

\item{nthreads}{\code{numeric(1)} Run \code{\link[=scan_sequences]{scan_sequences()}} in parallel with \code{nthreads}
threads. \code{nthreads = 0} uses all available threads.
Note that no speed up will occur for jobs with only a single motif and
sequence.}

\item{motif_pvalue.k}{\code{numeric(1)} Control \code{\link[=motif_pvalue]{motif_pvalue()}} approximation.
See \code{\link[=motif_pvalue]{motif_pvalue()}}.}

\item{use.gaps}{\code{logical(1)} Set this to \code{FALSE} to ignore motif gaps, if
present.}

\item{allow.nonfinite}{\code{logical(1)} If \code{FALSE}, then apply a pseudocount if
non-finite values are found in the PWM. Note that if the motif has a
pseudocount greater than zero and the motif is not currently of type PWM,
then this parameter has no effect as the pseudocount will be
applied automatically when the motif is converted to a PWM internally. This
value is set to \code{FALSE} by default in order to stay consistent with
pre-version 1.8.0 behaviour.}

\item{warn.NA}{\code{logical(1)} Whether to warn about the presence of non-standard
letters in the input sequence, such as those in masked sequences.}

\item{calc.pvals}{\code{logical(1)} Calculate P-values for each hit. This is a
convenience option which simply gives \code{motif_pvalue()} the input motifs
and the scores of each hit. Be careful about setting this to \code{TRUE} if
you anticipate getting thousands of hits: expect to wait a few seconds or
minutes for the calculations to finish. Increasing the \code{nthreads} value
can help greatly here. See Details for more information on P-value
calculation.}
}
\value{
\code{DataFrame} with each row representing one hit. If the input
sequences are \code{\link{DNAStringSet}} or
\code{\link{RNAStringSet}}, then an
additional column with the strand is included. Function args are stored
in the \code{metadata} slot.
}
\description{
For sequences of any alphabet, scan them using the PWM matrices of
a set of input motifs.
}
\details{
Similar to \code{\link[Biostrings:matchPWM]{Biostrings::matchPWM()}}, the scanning method uses
logodds scoring. (To see the scoring matrix for any motif, simply
run \code{convert_type(motif, "PWM")}. For a \code{multifreq} scoring
matrix: \code{apply(motif["multifreq"][["2"]], 2, ppm_to_pwm)}). In order
to score a sequence, at each position within a sequence of length equal
to the length of the motif, the scores for each base are summed. If the
score sum is above the desired threshold, it is kept.

If \code{threshold.type = 'logodds'}, then the \code{threshold} value is multiplied
by the maximum possible motif scores. To calculate the
maximum possible scores a motif (of type PWM) manually, run
\code{motif_score(motif, 1)}. If \code{threshold.type = 'pvalue'},
then threshold logodds scores are generated using \code{\link[=motif_pvalue]{motif_pvalue()}}.
Finally, if \code{threshold.type = 'logodds.abs'}, then the exact values
provided will be used as thresholds.

Non-standard letters (such as "N", "+", "-", ".", etc in \code{\link{DNAString}}
objects) will be safely ignored, resulting only in a warning and a very
minor performance cost. This can used to scan
masked sequences. See \code{\link[Biostrings:maskMotif]{Biostrings::mask()}}
for masking sequences
(generating \code{\link{MaskedXString}} objects), and \code{\link[Biostrings:injectHardMask]{Biostrings::injectHardMask()}}
to recover masked \code{\link{XStringSet}} objects for use with \code{\link[=scan_sequences]{scan_sequences()}}.
There is also a provided wrapper function which performs both steps: \code{\link[=mask_seqs]{mask_seqs()}}.

When \code{calc.pvals = TRUE}, \code{\link[=motif_pvalue]{motif_pvalue()}} will calculate the probabilities
of getting the input scores or higher, which is why it can take time to
calculate the P-values. If you simply wish to calculate the
probabilities of getting individual matches based on background frequencies,
then the following code can be used to achieve
this (using the list of input motifs and \code{\link[=scan_sequences]{scan_sequences()}} results):
\code{mapply(prob_match, motifs[scanRes$motif.i], scanRes$match)}. Of course
this only matters if you do not have uniform background frequencies, or
else the probability of each match is simply \code{(1 / nrow(motif))^ncol(motif)}.
}
\examples{
## any alphabet can be used
\dontrun{
set.seed(1)
alphabet <- paste(c(letters), collapse = "")
motif <- create_motif("hello", alphabet = alphabet)
sequences <- create_sequences(alphabet, seqnum = 1000, seqlen = 100000)
scan_sequences(motif, sequences)
}

## Sequence masking:
if (R.Version()$arch != "i386") {
library(Biostrings)
data(ArabidopsisMotif)
data(ArabidopsisPromoters)
seq <- mask_seqs(ArabidopsisPromoters, "AAAAA")
scan_sequences(ArabidopsisMotif, seq)
# A warning regarding the presence of non-standard letters will be given,
# but can be safely ignored in this case.
}

## Converting results to a GRanges object:
\dontrun{
res <- scan_sequences(ArabidopsisMotif, seq)
library(GenomicRanges)
makeGRangesFromDataFrame(res, seqnames.field = "sequence",
  keep.extra.columns = TRUE)
}

}
\seealso{
\code{\link[=add_multifreq]{add_multifreq()}}, \code{\link[Biostrings:matchPWM]{Biostrings::matchPWM()}},
\code{\link[=enrich_motifs]{enrich_motifs()}}, \code{\link[=motif_pvalue]{motif_pvalue()}}
}
\author{
Benjamin Jean-Marie Tremblay, \email{benjamin.tremblay@uwaterloo.ca}
}
